
class Word():
    # Lowercase english letters by ascii int values and dash char
    DEFAULT_VALID_CHARS = [chr(n) for n in range(97, 123)] + ['-']

    # Coefficient related to max possible number of ocurrences of individual chars in words 
    # Used in mapping vectors to the same signature-integers for permutations of same 
    # char list and ensure unique signature-integers for different char lists
    PARTITION_COEF = 4

    def __init__(self, charlist, valid_chars=None):
        self.__valid_chars = ''
        self.__charlist = ''
        self.__int_signature = 0
        self.__set_valid_chars(valid_chars)
        self.__set_charlist(charlist)
        self.__vector = [0 for _ in self.__valid_chars]
        
    def __set_valid_chars(self, valid_chars):
        # Valid char set generates all words in provided wordlist
        if not valid_chars:
            # no custom valid chars were provided
            self.__valid_chars = self.DEFAULT_VALID_CHARS
        else:
            if len(valid_chars):    
                self.__valid_chars = list(set(valid_chars))
            else:
                raise EmptyValidCharlist()

    def __set_charlist(self, charlist):
        # String of chars to unscramble and form words
        if set(charlist).issubset(self.__valid_chars):
            # Chars in this string must be a subset of valid chars
            # to ensure proper search results from wordlist
            self.__charlist = charlist
        else:
            raise InvalidChar()

    def __charlist_to_vector(self):
        # Encode provided char string to vector
        for ch in self.__charlist:
            # Get char index in vector
            i = self.__valid_chars.index(ch)  
            # Increment number of char occurrences 
            self.__vector[i] += 1 

    def __vector_to_int(self):
        # Map distinct vector to distinct integer (Injective function intended)
        # "Partition coefficient" is used to approximate injective function's behavior 
        # and avoid collisions while maintaining smaller integers than the ones 
        # generated by pairing functions like "Cantor Pairing Function"
        for i,n in enumerate(self.__vector):
            self.__int_signature += n*(2**(self.PARTITION_COEF*i))

    def get_int_signature(self):
        # Form string signature based on number of occurrences of each used char
        # Permutations of the same char string have identical signatures
        self.__charlist_to_vector()
        self.__vector_to_int()
        return self.__int_signature


class InvalidChar(Exception):
    def __init__(self):            
        super().__init__('Invalid char in charlist')


class EmptyValidCharlist(Exception):
    def __init__(self):            
        super().__init__('Provided valid char list is empty')
